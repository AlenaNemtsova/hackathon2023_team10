const button = document.querySelector(".startbutton");
const interview = document.querySelector(".interview-item");

const questionsHTML = [
  `<details><summary>Что такое валидация?</summary><p>Это проверка кода на соответствие правилам</p></details>`,
  `<details><summary>Какой тег мы используем для создания меню?</summary><p>Тег nav</p></details>`,
  `<details><summary>Чем плохо использовать div для всего?</summary><p>Если использовать один и тот же тег для всего, то автоматическим анализаторам страниц будет невозможно разобраться где что. Т.е. ридеры не смогут правильно прочитать страницу,
  а поисковые системы не смогут правильно ее проиндексировать.</p></details>`,
  `<details><summary>Какой атрибут выключает звук при воспроизведении видеофайла.?</summary><p></p></details>`,
  `<details><summary>Как сделать блок радиокнопок, чтобы выбирался только один пункт?</summary><p>Для этого используется атрибут name в теге input с типом radio. Все радиокнопки с одним и тем же name будут объединены в одну группу, внутри которой можно выбирать только 
  одну кнопку.</p></details>`,
];
const questionsCSS = [
  `<details><summary>Почему в большинстве ситуаций стоит использовать flexbox-позиционирование?</summary><p>Такое позиционирование обеспечивает максимально гибкую верстку, способную автоматически подстраиваться под изменение размера экрана у пользователя.</p></details>`,
  `<details><summary>Самостоятельно изучи способ позиционирования через display: table  и ответьте на вопрос, для каких ситуаций оно лучше всего подходит? </summary><p>Это способ изобразить таблицу с помощью css, не пользуясь соответствуюей разметкой html. Т.е. с помощью этого свойства можно изобразить таблицу из обычных строк. Подходит для того, чтобы делать таблицу из строк, когда это надо и менять размещение в других случаях.</p></details>`,
  `<details><summary>Какие есть оси во флекс-верстке и как задается их направление?</summary><p>Главная ось и поперечная ось. По умолчанию главная ось справа-налево, поперечная сверху-вниз. Направление главной оси задается свойством flex-direction.
  Row (по умолчанию) слева направо, row-reverse - справа-налево, column - сверху вниз и в этом случае поперечная ось будет уже слева направо. Column-reverse - снизу вверх.</p></details>`,
  `<details><summary>Разберитесь, как работает свойство margin: auto во флекс-верстке, приведите пример использования</summary><p>auto поровну распределяет пространство между правым и левым отступами. Т.е. может использоваться для центрирования элемента. Не работает для float, строчных и 
  абсолютно позиционированных элементов. Так же не работает, если не задана ширина. 
  auto для верхнего и нижнего оступов равно 0px.</p></details>`,
  `<details><summary>Как рассчитывается размер flex-контейнера?</summary><p>Размер, заданный шириной и высотой + внутренние отступы + ширина границы + внешние отступы.</p></details>`,
];
const questionsJS = [
  `<details><summary>Какие типы данных существуют в JavaScript?</summary><p>Число «number» - Единый тип число используется как для целых, так и для дробных чисел. Существуют специальные числовые значения Infinity (бесконечность) и NaN (ошибка вычислений). Например, бесконечность Infinity получается при делении на ноль. Ошибка вычислений NaN будет результатом некорректной математической операции.
  Строка «string»
  Булевый (логический) тип «boolean»
  Специальное значение «null» - В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках. Это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно».
  Специальное значение «undefined» - Значение undefined, как и null, образует свой собственный тип, состоящий из одного этого значения. Оно имеет смысл «значение не присвоено». Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть undefined.
  Символы «symbol» - «Символ» представляет собой уникальный идентификатор. Создаются новые символы с помощью функции Symbol(). Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.
  Тип «number» не может содержать числа больше, чем (253-1), или меньше, чем -(253-1). Тип «bigint» даёт возможность работать с целыми числами произвольной длины.
  Объекты «object» - Первые 7 типов называют «примитивными». Особняком стоит восьмой тип: «объекты». Он используется для коллекций данных и для объявления более сложных сущностей. Объявляются объекты при помощи фигурных скобок {...}</p></details>`,
  `<details><summary>Что такое цикл событий (event loop) и как он работает?</summary><p>Движок браузера выполняет JavaScript в одном потоке. Для потока выделяется область памяти — стэк, где хранятся фреймы (аргументы, локальные переменные) вызываемых функций.
  Список событий, подлежащих обработке формируют очередь событий. Когда стек освобождается, движок может обрабатывать событие из очереди. Координирование этого процесса и происходит в event loop.  
  Это по сути бесконечный цикл, в котором выполняются многочисленные обработчики событий. Если очередь пустая — движок браузера ждет, когда поступит событие. Если непустая — первое в ней событие извлекается и его обработчик начинает выполняться. И так до бесконечности.</p></details>`,
  `<details><summary>Что такое замыкание?</summary><p>Замыкание — это комбинация функции и лексического окружения, в котором эта функция была объявлена. Это окружение состоит из произвольного количества локальных переменных, которые были в области действия функции во время создания замыкания.</p></details>`,
];
const questionsReact = [
  `<details><summary>Какие методы жизненного цикла компонента существуют в React?</summary><p>render() — единственный обязательный метод в классовом компоненте.
  При вызове он проверяет this.props и this.state и возвращает один из следующих вариантов: Элемент React, Массивы и фрагменты, Порталы, Строки и числа, Booleans или null
  
  constructor() - Конструктор компонента React вызывается до того, как компонент будет примонтирован. В начале конструктора необходимо вызывать super(props). Если это не сделать, this.props не будет определён. Это может привести к багам.
  Конструкторы в React обычно используют для двух целей: Инициализация внутреннего состояния через присвоение объекта this.state. Привязка обработчиков событий к экземпляру.
  Конструктор — единственное место, где можно напрямую изменять this.state. В остальных методах необходимо использовать this.setState().
  
  componentDidMount() - вызывается сразу после монтирования (то есть, вставки компонента в DOM). В этом методе должны происходить действия, которые требуют наличия DOM-узлов. Это хорошее место для создания сетевых запросов.
  Этот метод подходит для настройки подписок. Но не забудьте отписаться от них в componentWillUnmount().
  
  componentDidUpdate(prevProps, prevState, snapshot) - вызывается сразу после обновления. Не вызывается при первом рендере. Метод позволяет работать с DOM при обновлении компонента. Также он подходит для выполнения таких сетевых запросов, которые выполняются на основании результата сравнения текущих пропсов с предыдущими. Если пропсы не изменились, новый запрос может и не требоваться.
  
  componentWillUnmount() - вызывается непосредственно перед размонтированием и удалением компонента. В этом методе выполняется необходимый сброс: отмена таймеров, сетевых запросов и подписок, созданных в componentDidMount().
  
  shouldComponentUpdate(nextProps, nextState) - вызывается перед рендером, когда получает новые пропсы или состояние. Значение по умолчанию равно true. Этот метод нужен только для повышения производительности.. Но не опирайтесь на его возможность «предотвратить» рендер, это может привести к багам. Вместо этого используйте PureComponent, который позволяет не описывать поведение shouldComponentUpdate() вручную. PureComponent поверхностно сравнивает пропсы и состояние и позволяет не пропустить необходимое обновление.
  
  static getDerivedStateFromProps(props, state) - вызывается непосредственно перед вызовом метода render, как при начальном монтировании, так и при последующих обновлениях. Он должен вернуть объект для обновления состояния или null, чтобы ничего не обновлять.
  Этот метод существует для редких случаев, когда состояние зависит от изменений в пропсах.
  
  getSnapshotBeforeUpdate(prevProps, prevState) - вызывается прямо перед этапом «фиксирования» (например, перед добавлением в DOM). Он позволяет вашему компоненту брать некоторую информацию из DOM (например, положение прокрутки) перед её возможным изменением. Любое значение, возвращаемое этим методом жизненного цикла, будет передано как параметр componentDidUpdate().
  
  static getDerivedStateFromError(error) - Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает ошибку в качестве параметра и возвращает значение для обновления состояния. getDerivedStateFromError() вызывается во время этапа «рендера». Поэтому здесь запрещены любые побочные эффекты, но их можно использовать в componentDidCatch().
  
  componentDidCatch(error, info) - Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает два параметра: error — перехваченная ошибка, info — объект с ключом componentStack, содержащий информацию о компоненте, в котором произошла ошибка. Метод можно использовать для логирования ошибок.
  </p></details>`,
  `<details><summary>Что такое Context в React и для чего он используется?</summary><p>Контекст разработан для передачи данных, которые можно назвать «глобальными» для всего дерева React-компонентов (например, текущий аутентифицированный пользователь, UI-тема или выбранный язык).
  Контекст позволяет избежать передачи пропсов в промежуточные компоненты</p></details>`,
  `<details><summary>Что такое Виртуальная DOM?</summary><p>Виртуальный DOM (VDOM) — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM. Этот процесс называется согласованием.

  Поскольку «виртуальный DOM» — это скорее паттерн, чем конкретная технология, этим термином иногда обозначают разные понятия. В мире React «виртуальный DOM» обычно ассоциируется с React-элементами , поскольку они являются объектами, представляющими пользовательский интерфейс. Тем не менее, React также использует внутренние объекты, называемые «волокнами» (fibers), чтобы хранить дополнительную информацию о дереве компонентов. Их также можно считать частью реализации «виртуального DOM» в React.</p></details>`,
];

function getRandomInt(max) {
  return Math.floor(Math.random() * max);
}

function getRandomQuestionHTML() {
  const randomIndex = getRandomInt(questionsHTML.length);
  return questionsHTML[randomIndex];
}

function getRandomQuestionCSS() {
  const randomIndex = getRandomInt(questionsCSS.length);
  return questionsCSS[randomIndex];
}

function getRandomQuestionJS() {
  const randomIndex = getRandomInt(questionsJS.length);
  return questionsJS[randomIndex];
}

function getRandomQuestionReact() {
  const randomIndex = getRandomInt(questionsReact.length);
  return questionsReact[randomIndex];
}

function startInterview() {
  const divForQuestions = document.createElement("div");
  divForQuestions.innerHTML = `${getRandomQuestionHTML()}<br>${getRandomQuestionCSS()}<br>${getRandomQuestionJS()}<br>${getRandomQuestionReact()}`;

  interview.append(divForQuestions);
}
button.addEventListener("click", startInterview);
